# 5.1.2. মেথড ওভাররাইডিং

কিছু সুপারক্লাস (**Employee**) এর মেথড সাবক্লাস (**Manager**) এর জন্য উপযুক্ত নয়। উদাহরণস্বরূপ, **getSalary** মেথডটি বেসিক বেতন (**salary**) এবং বোনাস (**bonus**) এর যোগফল রিটার্ন করা উচিত। এজন্য আমাদের সুপারক্লাসের মেথডটি ওভাররাইড করতে হবে:

```java
public class Manager extends Employee {
   . . .
   public double getSalary() {
      . . .
   }
   . . .
}
```

## প্রথম চেষ্টায় সমস্যা

প্রথম নজরে এটি সহজ মনে হতে পারে—শুধু **salary** এবং **bonus** যোগ করে রিটার্ন করলেই হবে:

```java
public double getSalary() {
   return salary + bonus; // কাজ করবে না
}
```

কিন্তু এটি কাজ করবে না, কারণ **salary** ফিল্ডটি **Employee** ক্লাসে **private** হিসেবে সংরক্ষিত। অর্থাৎ, **Manager** ক্লাস সরাসরি **salary** অ্যাক্সেস করতে পারবে না। যদি **Manager** ক্লাস এই প্রাইভেট ফিল্ড ব্যবহার করতে চায়, তবে তাকে **Employee** ক্লাসের পাবলিক মেথড ব্যবহার করতে হবে, যেমন **getSalary**।

## দ্বিতীয় চেষ্টায় নতুন সমস্যা

আমরা **getSalary()** মেথড ব্যবহার করে চেষ্টা করতে পারি:

```java
public double getSalary() {
   double baseSalary = getSalary(); // কাজ করবে না
   return baseSalary + bonus;
}
```

কিন্তু এই কোডেও সমস্যা আছে। **getSalary()** মেথডটি নিজেকেই পুনরায় কল করছে, কারণ **Manager** ক্লাসের মধ্যেই একটি **getSalary** মেথড রয়েছে। ফলে, এটি একটি **infinite recursion** তৈরি করবে, যা প্রোগ্রাম ক্র্যাশের কারণ হবে।

## সঠিক সমাধান: super কীওয়ার্ড ব্যবহার করা

আমরা যদি সুপারক্লাস (**Employee**) এর **getSalary()** মেথড কল করতে চাই, তাহলে আমাদের **super** কীওয়ার্ড ব্যবহার করতে হবে।

```java
public double getSalary() {
   double baseSalary = super.getSalary(); // সুপারক্লাসের মেথড কল করা
   return baseSalary + bonus;
}
```

এখানে **super.getSalary()** কল করলে এটি **Employee** ক্লাসের **getSalary()** মেথড কল করবে এবং বেসিক বেতন (**salary**) প্রদান করবে। এরপর আমরা **bonus** যোগ করে ফাইনাল সেলারি রিটার্ন করতে পারব।

## super এবং this এর মধ্যে পার্থক্য

অনেকে মনে করেন **super** এবং **this** একই রকম কাজ করে, কিন্তু এটি পুরোপুরি ঠিক নয়।

- **this** কীওয়ার্ড বর্তমান অবজেক্টের রেফারেন্স বোঝায়।
- **super** কীওয়ার্ড কোনো অবজেক্ট নয়, বরং এটি কম্পাইলারকে সুপারক্লাসের মেথড কল করতে বলে।

যেমন, আপনি **super** কে অন্য কোনো ভেরিয়েবলকে অ্যাসাইন করতে পারবেন না, কিন্তু **this** ব্যবহার করে বর্তমান অবজেক্টকে অ্যাসাইন করা সম্ভব।

## C++ তে সুপারক্লাস মেথড কল করার উপায়

Java তে আমরা সুপারক্লাসের মেথড কল করতে **super.getSalary()** ব্যবহার করি। কিন্তু C++ তে এটি করার জন্য **::** অপারেটর ব্যবহার করা হয়:

```cpp
double Manager::getSalary() {
   double baseSalary = Employee::getSalary();
   return baseSalary + bonus;
}
```

এখানে **Employee::getSalary()** দ্বারা সুপারক্লাসের মেথড কল করা হয়, যা Java-র **super.getSalary()** এর সমতুল্য।

## মেথড ওভাররাইডিং-এর সুবিধা

মেথড ওভাররাইডিং প্রোগ্রামিংয়ে গুরুত্বপূর্ণ ভূমিকা পালন করে। এর কিছু সুবিধা হল:

1. **পলিমরফিজম (Polymorphism):** এটি পলিমরফিজম সক্রিয় করে, যার ফলে একই মেথড ভিন্ন ক্লাসে বিভিন্নভাবে কাজ করতে পারে।
2. **কোড পুনঃব্যবহারযোগ্যতা (Code Reusability):** সুপারক্লাসের বিদ্যমান মেথড ব্যবহার করে নতুন ফিচার যোগ করা যায়।
3. **প্রবাহমানতা (Flexibility):** ওভাররাইডিং দ্বারা সাবক্লাসকে নিজস্ব কার্যকারিতা সংযোজনের সুযোগ দেওয়া হয়।
4. **রানটাইম পলিমরফিজম (Runtime Polymorphism):** প্রোগ্রাম এক্সিকিউশনের সময় কোন মেথড কল হবে তা নির্ধারিত হয়।

## উপসংহার

মেথড ওভাররাইডিং হল Java-তে একটি শক্তিশালী বৈশিষ্ট্য যা ইনহেরিটেন্সকে আরও কার্যকর এবং গতিশীল করে তোলে। **super** কীওয়ার্ড ব্যবহার করে আমরা সুপারক্লাসের মেথডগুলিকে পুনরায় ব্যবহার করতে পারি, যা আমাদের কোডকে পরিষ্কার ও দক্ষ করে তোলে।

